import type { CodeProject, GeneratedFile } from '../types/code-generation';

export const getMainFileName = (type: string, name: string, lang: string): string => {
  const ext = lang === 'typescript' ? 'ts' : 'js';
  const jsxExt = lang === 'typescript' ? 'tsx' : 'jsx';

  switch (type) {
    case 'component':
      return `src/components/${name}.${jsxExt}`;
    case 'hook':
      return `src/hooks/use${name}.${ext}`;
    case 'api':
      return `src/api/${name}.${ext}`;
    case 'function':
      return `src/utils/${name}.${ext}`;
    case 'class':
      return `src/classes/${name}.${ext}`;
    default:
      return `src/${name}.${ext}`;
  }
};

export const getTestFileName = (type: string, name: string, lang: string): string => {
  const ext = lang === 'typescript' ? 'ts' : 'js';
  const jsxExt = lang === 'typescript' ? 'tsx' : 'jsx';

  const testExt = type === 'component' ? jsxExt : ext;
  return `src/__tests__/${name}.test.${testExt}`;
};

export const generateEslintConfig = (): string => {
  return JSON.stringify({
    env: {
      browser: true,
      es2020: true,
      node: true
    },
    extends: [
      'eslint:recommended',
      '@typescript-eslint/recommended',
      'plugin:react/recommended',
      'plugin:react-hooks/recommended'
    ],
    parser: '@typescript-eslint/parser',
    parserOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true
      }
    },
    plugins: ['react', '@typescript-eslint'],
    rules: {
      'react/react-in-jsx-scope': 'off',
      '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
      'prefer-const': 'error',
      'no-var': 'error'
    },
    settings: {
      react: {
        version: 'detect'
      }
    }
  }, null, 2);
};

export const generateTsConfig = (): string => {
  return JSON.stringify({
    compilerOptions: {
      target: 'ES2020',
      useDefineForClassFields: true,
      lib: ['ES2020', 'DOM', 'DOM.Iterable'],
      module: 'ESNext',
      skipLibCheck: true,
      moduleResolution: 'bundler',
      allowImportingTsExtensions: true,
      resolveJsonModule: true,
      isolatedModules: true,
      noEmit: true,
      jsx: 'react-jsx',
      strict: true,
      noUnusedLocals: true,
      noUnusedParameters: true,
      noFallthroughCasesInSwitch: true
    },
    include: ['src'],
    references: [{ path: './tsconfig.node.json' }]
  }, null, 2);
};

export const generatePackageJson = (name: string, framework: string, features: string[]): string => {
  const dependencies: Record<string, string> = {
    react: '^18.2.0',
    'react-dom': '^18.2.0'
  };

  const devDependencies: Record<string, string> = {
    '@types/react': '^18.2.0',
    '@types/react-dom': '^18.2.0',
    typescript: '^5.0.0',
    vite: '^4.4.0'
  };

  if (framework === 'nextjs') {
    dependencies.next = '^13.4.0';
    delete dependencies['react-dom'];
  }

  if (features.includes('ESLint Configuration')) {
    devDependencies.eslint = '^8.45.0';
    devDependencies['@typescript-eslint/eslint-plugin'] = '^6.0.0';
  }

  if (features.includes('Unit Tests')) {
    devDependencies.vitest = '^0.34.0';
    devDependencies['@testing-library/react'] = '^13.4.0';
  }

  return JSON.stringify({
    name,
    version: '1.0.0',
    description: 'Generated by FlashFusion AI Code Generator',
    main: 'index.js',
    scripts: {
      dev: framework === 'nextjs' ? 'next dev' : 'vite',
      build: framework === 'nextjs' ? 'next build' : 'vite build',
      start: framework === 'nextjs' ? 'next start' : 'vite preview',
      test: features.includes('Unit Tests') ? 'vitest' : "echo 'No tests specified'",
      lint: features.includes('ESLint Configuration') ? 'eslint . --ext .ts,.tsx' : "echo 'No linting configured'"
    },
    dependencies,
    devDependencies,
    keywords: ['react', framework, 'typescript', 'generated'],
    author: 'FlashFusion AI',
    license: 'MIT'
  }, null, 2);
};

export const generateDependencies = (framework: string, features: string[]): string[] => {
  const deps = ['react', 'react-dom'];

  if (framework === 'nextjs') deps.push('next');
  if (framework === 'express') deps.push('express');
  if (features.includes('TypeScript Support')) deps.push('typescript');
  if (features.includes('Database Integration')) deps.push('prisma');
  if (features.includes('Authentication')) deps.push('jsonwebtoken');
  if (features.includes('Validation')) deps.push('zod');

  return deps;
};

export const generateScripts = (framework: string): Record<string, string> => {
  return {
    dev: framework === 'nextjs' ? 'next dev' : 'vite',
    build: framework === 'nextjs' ? 'next build' : 'vite build',
    start: framework === 'nextjs' ? 'next start' : 'vite preview'
  };
};

export const generateReactComponent = (name: string, description: string, features: string[]): string => {
  const componentName = name.charAt(0).toUpperCase() + name.slice(1);

  return `import React${features.includes('React Hook') ? ', { useState, useEffect }' : ''} from 'react';
${features.includes('CSS Modules') ? `import styles from './${name}.module.css';` : ''}

interface ${componentName}Props {
  children?: React.ReactNode;
  className?: string;
  variant?: 'primary' | 'secondary' | 'destructive';
  disabled?: boolean;
  onClick?: () => void;
}

/**
 * ${description}
 * 
 * @param props - Component props
 * @returns JSX element
 */
export function ${componentName}({
  children,
  className = '',
  variant = 'primary',
  disabled = false,
  onClick
}: ${componentName}Props) {
  ${features.includes('React Hook') ? `
  const [isLoading, setIsLoading] = useState(false);
  
  const handleClick = async () => {
    if (disabled || isLoading) return;
    
    setIsLoading(true);
    try {
      await onClick?.();
    } finally {
      setIsLoading(false);
    }
  };` : ''}

  return (
    <button
      className={\`\${styles.button} \${styles[variant]} \${className}\`}
      disabled={disabled${features.includes('React Hook') ? ' || isLoading' : ''}}
      onClick={${features.includes('React Hook') ? 'handleClick' : 'onClick'}}
      ${features.includes('Accessibility') ? `
      aria-label="${componentName}"
      role="button"` : ''}
    >
      ${features.includes('React Hook') ? '{isLoading ? "Loading..." : children}' : '{children}'}
    </button>
  );
}

export default ${componentName};`;
};

export const generateComponentStyles = (): string => {
  return `.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.5rem 1rem;
  border-radius: 0.375rem;
  font-weight: 500;
  transition: all 0.2s ease-in-out;
  cursor: pointer;
  border: 1px solid transparent;
  outline: none;
}

.button:focus-visible {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

.button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.primary {
  background-color: var(--primary);
  color: var(--primary-foreground);
}

.primary:hover:not(:disabled) {
  background-color: var(--primary-hover);
  transform: translateY(-1px);
}

.secondary {
  background-color: var(--secondary);
  color: var(--secondary-foreground);
}

.secondary:hover:not(:disabled) {
  background-color: var(--secondary-hover);
}

.destructive {
  background-color: var(--destructive);
  color: var(--destructive-foreground);
}

.destructive:hover:not(:disabled) {
  background-color: var(--destructive-hover);
}`;
};

export const generateAPIEndpoint = (name: string, description: string, features: string[]): string => {
  return `import { Request, Response, NextFunction } from 'express';
${features.includes('Database Integration') ? "import { db } from '../config/database';" : ''}
${features.includes('Validation') ? "import { z } from 'zod';" : ''}
${features.includes('Authentication') ? "import { authenticate } from '../middleware/auth';" : ''}

${features.includes('Validation') ? `
// Request validation schema
const ${name}Schema = z.object({
  // Add your validation rules here
  name: z.string().min(1),
  email: z.string().email(),
});

type ${name.charAt(0).toUpperCase() + name.slice(1)}Request = z.infer<typeof ${name}Schema>;
` : ''}

/**
 * ${description}
 */
export class ${name.charAt(0).toUpperCase() + name.slice(1)}Controller {
  ${features.includes('Authentication') ? '@authenticate' : ''}
  async create(req: Request, res: Response, next: NextFunction) {
    try {
      ${features.includes('Validation') ? `
      // Validate request body
      const validatedData = ${name}Schema.parse(req.body);
      ` : 'const data = req.body;'}
      
      ${features.includes('Database Integration') ? `
      // Save to database
      const result = await db.${name}.create({
        data: ${features.includes('Validation') ? 'validatedData' : 'data'}
      });
      ` : `
      // Process the data
      const result = { id: Date.now(), ...${features.includes('Validation') ? 'validatedData' : 'data'} };
      `}
      
      ${features.includes('Logging') ? `console.log(\`Created new ${name}: \${result.id}\`);` : ''}
      
      res.status(201).json({
        success: true,
        data: result
      });
    } catch (error) {
      ${features.includes('Error Handling') ? `
      console.error('Error creating ${name}:', error);
      
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: error.errors
        });
      }
      
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
      ` : 'next(error);'}
    }
  }

  async getAll(req: Request, res: Response, next: NextFunction) {
    try {
      ${features.includes('Database Integration') ? `
      const items = await db.${name}.findMany({
        orderBy: { createdAt: 'desc' }
      });
      ` : `
      const items = []; // Mock data
      `}
      
      res.json({
        success: true,
        data: items
      });
    } catch (error) {
      ${features.includes('Error Handling') ? `
      console.error('Error fetching ${name}s:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
      ` : 'next(error);'}
    }
  }

  async getById(req: Request, res: Response, next: NextFunction) {
    try {
      const { id } = req.params;
      
      ${features.includes('Database Integration') ? `
      const item = await db.${name}.findUnique({
        where: { id: parseInt(id) }
      });
      ` : `
      const item = null; // Mock data
      `}
      
      if (!item) {
        return res.status(404).json({
          success: false,
          error: '${name.charAt(0).toUpperCase() + name.slice(1)} not found'
        });
      }
      
      res.json({
        success: true,
        data: item
      });
    } catch (error) {
      ${features.includes('Error Handling') ? `
      console.error('Error fetching ${name}:', error);
      res.status(500).json({
        success: false,
        error: 'Internal server error'
      });
      ` : 'next(error);'}
    }
  }
}

export default new ${name.charAt(0).toUpperCase() + name.slice(1)}Controller();`;
};

export const generateReactHook = (name: string, description: string): string => {
  const hookName = `use${name.charAt(0).toUpperCase() + name.slice(1)}`;

  return `import { useState, useEffect, useCallback } from 'react';

interface ${hookName}Options {
  initialValue?: any;
  onSuccess?: (data: any) => void;
  onError?: (error: Error) => void;
}

interface ${hookName}Return {
  data: any;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
  reset: () => void;
}

/**
 * ${description}
 * 
 * @param options - Hook configuration options
 * @returns Hook state and methods
 */
export function ${hookName}(options: ${hookName}Options = {}): ${hookName}Return {
  const { initialValue = null, onSuccess, onError } = options;
  
  const [data, setData] = useState(initialValue);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Implement your data fetching logic here
      const response = await fetch('/api/${name}');
      
      if (!response.ok) {
        throw new Error('Failed to fetch data');
      }
      
      const result = await response.json();
      setData(result);
      onSuccess?.(result);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      onError?.(error);
    } finally {
      setLoading(false);
    }
  }, [onSuccess, onError]);

  const reset = useCallback(() => {
    setData(initialValue);
    setError(null);
    setLoading(false);
  }, [initialValue]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
    reset
  };
}

export default ${hookName};`;
};

export const generateTestFile = (name: string, codeType: string): string => {
  const componentName = name.charAt(0).toUpperCase() + name.slice(1);

  return `import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import ${componentName} from './${name}';

describe('${componentName}', () => {
  it('renders correctly', () => {
    render(<${componentName}>Test Content</${componentName}>);
    
    expect(screen.getByText('Test Content')).toBeInTheDocument();
  });

  it('handles click events', () => {
    const handleClick = vi.fn();
    
    render(
      <${componentName} onClick={handleClick}>
        Click me
      </${componentName}>
    );
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('respects disabled state', () => {
    const handleClick = vi.fn();
    
    render(
      <${componentName} disabled onClick={handleClick}>
        Disabled
      </${componentName}>
    );
    
    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
    
    fireEvent.click(button);
    expect(handleClick).not.toHaveBeenCalled();
  });

  it('applies variant classes correctly', () => {
    render(<${componentName} variant="secondary">Secondary</${componentName}>);
    
    const button = screen.getByRole('button');
    expect(button).toHaveClass('secondary');
  });
});`;
};

export const generateReadme = (name: string, description: string, framework: string): string => {
  return `# ${name}

${description}

## Overview

This project was generated using FlashFusion AI Code Generator with ${framework} framework.

## Features

- ðŸš€ Built with ${framework}
- ðŸ’Ž TypeScript support
- ðŸŽ¨ Modern CSS styling
- ðŸ§ª Test suite included
- ðŸ“¦ Ready for production

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn

### Installation

1. Install dependencies:
\`\`\`bash
npm install
\`\`\`

2. Start the development server:
\`\`\`bash
npm run dev
\`\`\`

3. Open [http://localhost:3000](http://localhost:3000) in your browser.

## Available Scripts

- \`npm run dev\` - Start development server
- \`npm run build\` - Build for production
- \`npm run start\` - Start production server
- \`npm test\` - Run test suite
- \`npm run lint\` - Run linter

## Project Structure

\`\`\`
${name}/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/     # React components
â”‚   â”œâ”€â”€ hooks/          # Custom hooks
â”‚   â”œâ”€â”€ api/           # API endpoints
â”‚   â””â”€â”€ __tests__/     # Test files
â”œâ”€â”€ public/            # Static assets
â”œâ”€â”€ package.json       # Dependencies and scripts
â””â”€â”€ README.md         # This file
\`\`\`

## Contributing

1. Fork the repository
2. Create your feature branch (\`git checkout -b feature/amazing-feature\`)
3. Commit your changes (\`git commit -m 'Add some amazing feature'\`)
4. Push to the branch (\`git push origin feature/amazing-feature\`)
5. Open a Pull Request

## License

This project is licensed under the MIT License.

## Generated by FlashFusion

This project was generated using [FlashFusion AI Code Generator](https://flashfusion.ai) - Build faster with AI-powered development tools.
`;
};

export const generateDockerfile = (): string => {
  return `# Use official Node.js runtime as base image
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Expose port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
`;
};

export const buildMockProjectFiles = (options: {
  name: string;
  description: string;
  codeType: string;
  framework: string;
  selectedFeatures: string[];
  includeTests: boolean;
  includeDocs: boolean;
}): GeneratedFile[] => {
  const {
    name,
    description,
    codeType,
    framework,
    selectedFeatures,
    includeTests,
    includeDocs
  } = options;

  const files: GeneratedFile[] = [];

  if (codeType === 'component' && framework === 'react') {
    files.push({
      path: `src/components/${name}.tsx`,
      content: generateReactComponent(name, description, selectedFeatures),
      language: 'typescript',
      size: 1024
    });

    files.push({
      path: `src/components/${name}.module.css`,
      content: generateComponentStyles(),
      language: 'css',
      size: 512
    });
  }

  if (codeType === 'api') {
    files.push({
      path: `src/api/${name}.ts`,
      content: generateAPIEndpoint(name, description, selectedFeatures),
      language: 'typescript',
      size: 2048
    });
  }

  if (codeType === 'hook') {
    files.push({
      path: `src/hooks/use${name}.ts`,
      content: generateReactHook(name, description),
      language: 'typescript',
      size: 756
    });
  }

  files.push({
    path: 'package.json',
    content: generatePackageJson(name, framework, selectedFeatures),
    language: 'json',
    size: 512
  });

  files.push({
    path: 'tsconfig.json',
    content: generateTsConfig(),
    language: 'json',
    size: 256
  });

  if (includeTests) {
    files.push({
      path: `src/__tests__/${name}.test.tsx`,
      content: generateTestFile(name, codeType),
      language: 'typescript',
      size: 1024
    });
  }

  if (includeDocs) {
    files.push({
      path: 'README.md',
      content: generateReadme(name, description, framework),
      language: 'markdown',
      size: 2048
    });
  }

  if (selectedFeatures.includes('ESLint Configuration')) {
    files.push({
      path: '.eslintrc.json',
      content: generateEslintConfig(),
      language: 'json',
      size: 256
    });
  }

  if (selectedFeatures.includes('Docker Support')) {
    files.push({
      path: 'Dockerfile',
      content: generateDockerfile(),
      language: 'dockerfile',
      size: 512
    });
  }

  return files;
};

export const buildProjectSummary = (project: CodeProject): string => {
  return `Generated project: ${project.name}\nFiles: ${project.files.length}`;
};
